{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport absf from '@stdlib/math-base-special-absf';\nimport maxf from '@stdlib/math-base-special-maxf';\nimport f32 from '@stdlib/number-float64-base-to-float32';\nimport FLOAT32_BIGGEST from '@stdlib/constants-float32-max';\nimport FLOAT32_SMALLEST from '@stdlib/constants-float32-smallest-normal';\nimport EPS from '@stdlib/constants-float32-eps';\nimport Complex64 from '@stdlib/complex-float32-ctor';\nimport realf from '@stdlib/complex-float32-real';\nimport imagf from '@stdlib/complex-float32-imag';\n\n\n// VARIABLES //\n\nvar ONE = f32( 1.0 );\nvar TWO = f32( 2.0 );\nvar HALF = f32( 0.5 );\nvar LARGE_THRESHOLD = f32( FLOAT32_BIGGEST * HALF );\nvar SMALL_THRESHOLD = f32( FLOAT32_SMALLEST * f32( TWO/EPS ) );\nvar RECIP_EPS_SQR = f32( TWO / f32(EPS*EPS) );\n\n\n// MAIN //\n\n/**\n* Computes the inverse of a single-precision complex floating-point number.\n*\n* ## References\n*\n* -   Baudin, Michael, and Robert L. Smith. 2012. \"A Robust Complex Division in Scilab.\" _arXiv_ abs/1210.4539 \\[cs.MS\\] (October): 1â€“25. <https://arxiv.org/abs/1210.4539>.\n*\n* @param {Complex64} z - complex number\n* @returns {Complex64} result\n*\n* @example\n* import Complex64 from '@stdlib/complex-float32-ctor';\n* import realf from '@stdlib/complex-float32-real';\n* import imagf from '@stdlib/complex-float32-imag';\n*\n* var v = cinvf( new Complex64( 2.0, 4.0 ) );\n* // returns <Complex64>\n*\n* var re = realf( v );\n* // returns ~0.1\n*\n* var im = imagf( v );\n* // returns ~-0.2\n*/\nfunction cinvf( z ) {\n\tvar ab;\n\tvar re;\n\tvar im;\n\tvar s;\n\tvar r;\n\tvar t;\n\n\tre = realf( z );\n\tim = imagf( z );\n\tab = maxf( absf(re), absf(im) );\n\ts = ONE;\n\tif ( ab >= LARGE_THRESHOLD ) {\n\t\tre = f32( re * HALF );\n\t\tim = f32( im * HALF );\n\t\ts = f32( s * HALF );\n\t} else if ( ab <= SMALL_THRESHOLD ) {\n\t\tre = f32( re * RECIP_EPS_SQR );\n\t\tim = f32( im * RECIP_EPS_SQR );\n\t\ts = f32( s * RECIP_EPS_SQR );\n\t}\n\tif ( absf( im ) <= absf( re ) ) {\n\t\tr = f32( im / re );\n\t\tt = f32( ONE / f32( re + f32(im*r) ) );\n\t\tre = t;\n\t\tim = f32( -r * t );\n\t} else {\n\t\tr = f32( re / im );\n\t\tt = f32( ONE / f32( im + f32(re*r) ) );\n\t\tre = f32( r * t );\n\t\tim = -t;\n\t}\n\tre = f32( re * s );\n\tim = f32( im * s );\n\treturn new Complex64( re, im );\n}\n\n\n// EXPORTS //\n\nexport default cinvf;\n"],"names":["ONE","f32","TWO","HALF","LARGE_THRESHOLD","FLOAT32_BIGGEST","SMALL_THRESHOLD","FLOAT32_SMALLEST","EPS","RECIP_EPS_SQR","cinvf","z","ab","re","im","s","r","t","realf","imagf","maxf","absf","Complex64"],"mappings":";;62BAmCA,IAAIA,EAAMC,EAAK,GACXC,EAAMD,EAAK,GACXE,EAAOF,EAAK,IACZG,EAAkBH,EAAKI,EAAkBF,GACzCG,EAAkBL,EAAKM,EAAmBN,EAAKC,EAAIM,IACnDC,EAAgBR,EAAKC,EAAMD,EAAIO,EAAIA,IA6BvC,SAASE,EAAOC,GACf,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EA4BJ,OA1BAJ,EAAKK,EAAOP,GACZG,EAAKK,EAAOR,GACZC,EAAKQ,EAAMC,EAAKR,GAAKQ,EAAKP,IAC1BC,EAAIf,EACCY,GAAMR,GACVS,EAAKZ,EAAKY,EAAKV,GACfW,EAAKb,EAAKa,EAAKX,GACfY,EAAId,EAAKc,EAAIZ,IACFS,GAAMN,IACjBO,EAAKZ,EAAKY,EAAKJ,GACfK,EAAKb,EAAKa,EAAKL,GACfM,EAAId,EAAKc,EAAIN,IAETY,EAAMP,IAAQO,EAAMR,IACxBG,EAAIf,EAAKa,EAAKD,GAEdA,EADAI,EAAIhB,EAAKD,EAAMC,EAAKY,EAAKZ,EAAIa,EAAGE,KAEhCF,EAAKb,GAAMe,EAAIC,KAEfD,EAAIf,EAAKY,EAAKC,GACdG,EAAIhB,EAAKD,EAAMC,EAAKa,EAAKb,EAAIY,EAAGG,KAChCH,EAAKZ,EAAKe,EAAIC,GACdH,GAAMG,GAEPJ,EAAKZ,EAAKY,EAAKE,GACfD,EAAKb,EAAKa,EAAKC,GACR,IAAIO,EAAWT,EAAIC,EAC3B"}